Function check_double_captures:
  IF capture_moves IS EMPTY:
      RETURN

  potential_double_capture_moves = []
  FOR each move in capture_moves:
      ADD top-left and top-right potential targets
  END FOR

  double_capture_targets = []
  FOR each move in potential_double_capture_moves:
      IF move IS in bounds:
          ADD to double_capture_targets
  END FOR

  FOR each target in double_capture_targets:
      FIND the captured piece
      FOR landing_square in [left, right]:
          CALCULATE landing_square
          IF landing_square IS in bounds AND empty:
              ADD to capture_moves
              ADD captured piece to capture_pieces
      END FOR
  END FOR
END Function



### Tree Diagram for List Branching in `check_double_captures`

#### Overview:
The function begins with an existing `capture_moves` list and branches into new lists as it processes potential double captures, filters valid targets, and identifies landing squares. Below is a tree-like representation of how these lists are formed.

```
1. Initial List: capture_moves
   - Example: [(2, 4)]

2. Generate potential_double_capture_moves:
   - Branches from `capture_moves`.
   - Two new tuples are added for each entry in `capture_moves`:
     
     (capture_moves[0][0] - 1, capture_moves[0][1] - 1)  # Top-left
     (capture_moves[0][0] - 1, capture_moves[0][1] + 1)  # Top-right

   - Example Result: [(1, 3), (1, 5)]

3. Add More to potential_double_capture_moves:
   - If `capture_moves` has more than one entry, repeat for the second entry:

     (capture_moves[1][0] - 1, capture_moves[1][1] - 1)  # Top-left
     (capture_moves[1][0] - 1, capture_moves[1][1] + 1)  # Top-right

   - Example Result (after both steps):
     [(1, 3), (1, 5), (1, 3), (1, 5)]  # Includes duplicates

4. Filter into double_capture_targets:
   - From `potential_double_capture_moves`, remove tuples where any element is out of bounds (<= 0 or >= 8).
   - Example Filtered Result:
     [(1, 3), (1, 5)]

5. Process double_capture_targets:
   - For each target tuple:

     a. Identify the captured piece: Use `find_piece(target[0], target[1])`.
     b. Calculate potential landing squares:

        - Left Landing Square:
          (target[0] - 1, target[1] - 1)
        
        - Right Landing Square:
          (target[0] - 1, target[1] + 1)

     c. Validate landing squares:
        - Check bounds (8 > row > 0 and 8 > col > 0).
        - Ensure landing square is empty.

     d. Append to capture_moves and capture_pieces:
        - Valid landing squares are added to `capture_moves`.
        - Captured pieces are added to `capture_pieces`.

   - Example Process:
     - For target (1, 3):
       - Left Landing: (0, 2)
       - Right Landing: (0, 4)
       - Append valid moves and pieces.

   - Result:
     - capture_moves: [(0, 2), (0, 4)]
     - capture_pieces: [(1, 3)]
```

